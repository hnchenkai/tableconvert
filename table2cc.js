// 目标是把资源转成c++可以自动加载的代码
// 自动化代码负责完成结构的定义 和数据的加载 
// 加载json数据使用 parson模块,数据导出的是一个资源的mgr类

function CreateTalbeRes(resName, resObj, out) {
    CreateTalbeResHead(resName, resObj, out);
    CreateTalbeResSt(resName, resObj, out);
    CreateTalbeResClass(resName, resObj, out);
    CreateTalbeReEnd(resName, resObj, out);
}

function CreateTalbeResHead(resName, resObj, out) {
    out.h = "// Generated by the chenkai xlsx2json compiler.  DO NOT EDIT!\n";
    out.h += "// source: " + resName + ".json\n";
    out.h += '#pragma once\n';
    out.h += '#include <unordered_map>\n';
    out.h += '#include <string>\n';
    out.h += '#include <array>\n';
    out.h += '#include <vector>\n';
    out.h += '#define number double\n';
    out.h += '#define string std::string\n';
    out.h += '#define Array std::vector\n';

    out.cc = "// Generated by the chenkai xlsx2json compiler.  DO NOT EDIT!\n";
    out.cc += "// source: " + resName + ".json\n";
    out.cc += '#include "SeRes' + resName + '.json.h"\n';
    out.cc += '#include "TeJson.h"\n';
}


function CreateTalbeReEnd(resName, resObj, out) {
    out.h += '#undef number\n';
    out.h += '#undef string\n';
    out.h += '#undef Array\n';
}

function CreateTalbeResSt(resName, resObj, out) {

    var stName = 'SeRes' + resName;
    var STRUCTst = 'struct ' + stName + '{\n';
    STRUCTst += '\t' + stName + '();\n';
    var CONSTRUCTORFun = stName + '::' + stName + '(){\n';

    for (var key in resObj) {
        STRUCTst += '\t' + resObj[key] + ' ' + key + ';\n';
        switch (resObj[key]) {
            case 'string':
                {
                    CONSTRUCTORFun += '\t' + key + '="";\n';
                    break;
                }
            case 'number':
                {
                    CONSTRUCTORFun += '\t' + key + '=0;\n';
                    break;
                }
            case 'Array<number>':
                {
                    CONSTRUCTORFun += '\t' + key + '.clear();\n';
                    break;
                }
            case 'Array<string>':
                {
                    CONSTRUCTORFun += '\t' + key + '.clear();\n';
                    break;
                }
            default:
                break;
        }

    }
    CONSTRUCTORFun += "}\n";
    STRUCTst += '};\ntypedef std::unordered_map<string, ' + stName + '*> MapP' + resName + ';\n';

    out.h += STRUCTst;
    out.cc += CONSTRUCTORFun;
}

function CreateIniliseFun(resName, resObj, out) {
    var className = 'SeRes' + resName + 'Mgr';
    var stName = 'SeRes' + resName;

    var InitialiseFun = 'bool ' + className + '::Initialise(std::string kResPath){\n';
    InitialiseFun += '\tTeJSonObject kObject;\n';
    InitialiseFun += '\tkObject.ParseFile((kResPath + "/' + resName + '.json").c_str());\n';
    InitialiseFun += '\tif (!kObject.IsValid()){\n\t\treturn false;\n\t}\n';

    InitialiseFun += '\tfor (int i = 0; i < (int)kObject.Size(); i++){\n';
    InitialiseFun += '\t\tstd::string kKey = kObject.GetChildObjectKey(i);\n';
    InitialiseFun += '\t\tif (kKey == "Template") {\n\t\t\tcontinue;\n\t\t}\n';
    InitialiseFun += '\t\t' + stName + '* pkRes = new ' + stName + '();\n';
    InitialiseFun += '\t\tTeJSonObject kOneRes = kObject[i];\n';

    for (var key in resObj) {
        switch (resObj[key]) {
            case 'string':
                {
                    InitialiseFun += '\t\tpkRes->' + key + '=kOneRes.GetChaildObject("' + key + '").ToString();;\n';
                    break;
                }
            case 'number':
                {
                    InitialiseFun += '\t\tpkRes->' + key + '=kOneRes.GetChaildObject("' + key + '").ToNumber();;\n';
                    break;
                }
            case 'Array<number>':
                {
                    InitialiseFun += '\t\tTeJSonObject ' + key + 'Obj = kOneRes.GetChaildObject("' + key + '");\n'
                    InitialiseFun += '\t\tfor (int j = 0; j < (int)' + key + 'Obj.Size(); j++){\n';
                    InitialiseFun += '\t\t\tpkRes->' + key + '.push_back(' + key + 'Obj[j].ToNumber());\n';
                    InitialiseFun += '\t\t}\n';
                    break;
                }
            case 'Array<string>':
                {
                    InitialiseFun += '\t\tTeJSonObject ' + key + 'Obj = kOneRes.GetChaildObject("' + key + '");\n'
                    InitialiseFun += '\t\tfor (int j = 0; j < (int)' + key + 'Obj.Size(); j++){\n';
                    InitialiseFun += '\t\t\tpkRes->' + key + '.push_back(' + key + 'Obj[j].ToString());\n';
                    InitialiseFun += '\t\t}\n';
                    break;
                }
            default:
                break;
        }

    }

    InitialiseFun += '\t\tm_kPMapRes[kObject.GetChildObjectKey(i)] = pkRes;\n';
    InitialiseFun += '\t};\n';
    InitialiseFun += '\treturn true;\n';
    InitialiseFun += '};\n';
    out.cc += InitialiseFun;

    out.h += '\tbool Initialise(string kResPath);\n';
}

function CreateConstructFun(resName, resObj, out) {
    var className = 'SeRes' + resName + 'Mgr';
    var stName = 'SeRes' + resName;
    var mapStr = 'MapP' + resName;

    out.h += '\t' + className + '();\n';
    out.h += '\t~' + className + '();\n';

    out.cc += className + '::' + className + '(){\n';
    out.cc += '}\n';
    out.cc += className + '::~' + className + '(){\n';
    out.cc += "\tfor (" + mapStr + "::iterator itr = m_kPMapRes.begin(); itr != m_kPMapRes.end(); itr++){\n";
    out.cc += "\t\tdelete itr->second;\n";
    out.cc += "\t}\n";
    out.cc += "\tm_kPMapRes.clear();\n";
    out.cc += '}\n';
}

function CreateFindResFun(resName, resObj, out) {
    var className = 'SeRes' + resName + 'Mgr';
    var stName = 'SeRes' + resName;
    var mapStr = 'MapP' + resName;

    out.h += '\tconst ' + stName + '* Find' + resName + '(string kID);\n';

    out.cc += 'const ' + stName + '* ' + className + '::Find' + resName + '(std::string kID){\n';
    out.cc += '\t' + mapStr + "::iterator itr = m_kPMapRes.find(kID);\n";

    out.cc += '\tif (itr != m_kPMapRes.end()) {\n';
    out.cc += '\t\treturn itr ->second;\n';
    out.cc += '\t}\n';

    out.cc += '\treturn NULL;\n';
    out.cc += '}\n';
}

function CreateGetAllResFun(resName, resObj, out) {
    var className = 'SeRes' + resName + 'Mgr';
    var stName = 'SeRes' + resName;
    var mapStr = 'MapP' + resName;

    out.h += '\tconst ' + mapStr + '& GetAll' + resName + '();\n';

    out.cc += 'const ' + mapStr + '& ' + className + '::GetAll' + resName + '(){\n';
    out.cc += '\treturn m_kPMapRes;\n';
    out.cc += '}\n';
}

function CreateTalbeResClass(resName, resObj, out) {

    var className = 'SeRes' + resName + 'Mgr';
    var stName = 'SeRes' + resName;
    var mapStr = 'MapP' + resName;
    out.h += 'class ' + className + '{\n';
    out.h += 'public:\n';
    CreateConstructFun(resName, resObj, out);
    CreateIniliseFun(resName, resObj, out);
    CreateFindResFun(resName, resObj, out);
    CreateGetAllResFun(resName, resObj, out);
    out.h += 'private:\n';
    out.h += '\t' + mapStr + ' m_kPMapRes;\n';
    out.h += '\t};\n';


}

module.exports.CreateTalbeRes = CreateTalbeRes;